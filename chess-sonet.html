<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Chess Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #0a0a0f;
            font-family: 'Roboto', sans-serif;
            display: flex;
            justify-content: center;
            min-height: 100vh;
            /* color: #00ff00; */
        }

        .game-container {
            display: flex;
            gap: 30px;
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px;
            gap: 20px;
            width: 100%;
        }

        .game-left {
            flex: 1;
            max-width: 400px;
        }

        .game-right {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .board {
            width: 100%;
            max-width: 400px;
            height: auto;
            aspect-ratio: 1;
            margin: 0 auto;
            border-radius: 4px;
            box-shadow: 0 0 20px #ff00ff, 0 0 40px #ff00ff80;
            overflow: hidden;
            background: #1a1a2e;
            display: grid;
            grid-template: repeat(8, 1fr) / repeat(8, 1fr);
            border: 2px solid #ff00ff;
        }

        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: min(5vw, 2.2em);
            cursor: pointer;
            transition: all 0.2s ease;
            text-shadow: none; /* Remove existing text shadow */
            position: relative;
        }

        /* White pieces get cyan glow */
        .square:has(span.white-piece) {
            color: #fff;
            text-shadow: 0 0 10px #00ffff,
                        0 0 20px #00ffff,
                        0 0 30px #00ffff;
        }

        /* Black pieces get magenta glow */
        .square:has(span.black-piece) {
            color: #ffffff;
            text-shadow: 0 0 10px #ffffff,
                        0 0 20px #000000,
                        0 0 30px #000000;
        }

        .white-piece {
            color: #fff;
            filter: brightness(1.2);
        }

        .black-piece {
            color: #000000;
            filter: brightness(1.2);
        }

        /* Enhance selected piece glow */
        .selected:has(span.white-piece) {
            background: #103040 !important;
            box-shadow: inset 0 0 30px #00ffff;
        }

        .selected:has(span.black-piece) {
            background: #401040 !important;
            box-shadow: inset 0 0 30px #ff00ff;
        }

        .square:hover {
            transform: scale(1.05);
            z-index: 1;
            box-shadow: inset 0 0 20px #00ffff80;
        }

        .white { background: #1a1a2e; }
        .black { background: #2a2a4e; }
        
        .selected { 
            background: #4a1a4e !important;
            box-shadow: inset 0 0 30px #ff00ff;
            text-shadow: 0 0 15px #ff00ff;
        }

        .valid-move::after {
            content: '';
            position: absolute;
            width: 25px;
            height: 25px;
            background: #00ffff40;
            border: 2px solid #00ffff;
            border-radius: 50%;
            box-shadow: 0 0 10px #00ffff;
            opacity: 0.8;
            transition: all 0.2s ease;
        }

        .valid-capture::after {
            border: 2px solid #ff00ff;
            background: #ff00ff40;
            box-shadow: 0 0 10px #ff00ff;
        }

        .game-info {
            background: #1a1a2e;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px #00ffff80;
            border: 1px solid #00ffff;
        }

        #turn {
            font-size: 1.5em;
            font-weight: 500;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            margin-bottom: 10px;
        }

        #status {
            font-size: 1.2em;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
            font-weight: 300;
        }

        .game-log {
            background: #1a1a2e;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px #00ffff80;
            border: 1px solid #00ffff;
            max-height: 300px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 8px;
            border-bottom: 1px solid #2a2a4e;
            color: #00ffff;
            font-size: 0.9em;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            
            .game-right {
                width: 100%;
                max-width: 400px;
            }

            body {
                padding: 10px;
            }

            .game-container {
                flex-direction: column;
            }
            
            .game-left, .game-right {
                width: 100%;
                max-width: 100%;
            }

            .difficulty-control, .game-info, .game-log {
                margin-bottom: 10px;
                padding: 15px;
            }

            .game-log {
                max-height: 200px;
            }

            #turn {
                font-size: 1.2em;
            }

            .difficulty-label {
                font-size: 1em;
            }
        }

        @media (max-width: 480px) {
            .square {
                font-size: 6vw;
            }

            .game-log {
                max-height: 150px;
            }
        }

        .spinner {
            display: none;  /* Changed from display: inline-block */
            width: 20px;
            height: 20px;
            border: 3px solid #1a1a2e;
            border-top: 3px solid #00ffff;
            border-radius: 50%;
            margin-left: 10px;
            animation: spin 1s linear infinite;
            vertical-align: middle;
            box-shadow: 0 0 15px #00ffff;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #turn {
            display: flex;
            align-items: center;
        }

        .difficulty-control {
            background: #1a1a2e;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px #00ffff80;
            border: 1px solid #00ffff;
            margin-bottom: 20px;
        }

        .difficulty-slider {
            width: 100%;
            margin: 10px 0;
            appearance: none;
            height: 4px;
            background: #2a2a4e;
            border-radius: 2px;
            outline: none;
        }

        .difficulty-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: #ff00ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 15px #ff00ff;
        }

        .difficulty-label {
            font-size: 1.1em;
            color: #00ffff;
            display: flex;
            justify-content: space-between;
            align-items: center;
            text-shadow: 0 0 5px #00ffff;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-left">
            <div class="difficulty-control">
                <div class="difficulty-label">
                    <span>AI Difficulty:</span>
                    <span id="depth-value">3</span>
                </div>
                <input type="range" min="1" max="5" value="3" class="difficulty-slider" id="depth-slider">
            </div>
            <div class="board" id="board"></div>
        </div>
        <div class="game-right">
            <div class="game-info">
                <div id="turn">White's turn</div>
                <div id="status"></div>
            </div>
            <div class="game-log" id="game-log"></div>
        </div>
    </div>

    <script>
        const PIECES = {
            WHITE: {
                KING: '♔', QUEEN: '♕', ROOK: '♖',
                BISHOP: '♗', KNIGHT: '♘', PAWN: '♙'
            },
            BLACK: {
                KING: '♚', QUEEN: '♛', ROOK: '♜',
                BISHOP: '♝', KNIGHT: '♞', PAWN: '♟'
            }
        };

        class Chess {
            constructor() {
                this.board = Array(8).fill().map(() => Array(8).fill(null));
                this.selectedPiece = null;
                this.currentPlayer = 'WHITE';
                this.validMoves = [];
                this.lastPawnDoubleMove = null; // Add this line
                this.setupBoard();
                this.renderBoard();
                this.gameOver = false; // Add this line
                this.moveHistory = [];
                this.initializeLogging();
                this.validMovesCache = new Map(); // Add cache for valid moves
                this.computeAllValidMoves(); // Initial computation
                this.isAIEnabled = true; // Add this line
                this.searchDepth = 3; // Add default search depth
                this.initializeControls(); // Add this line
            }

            initializeLogging() {
                this.log('Game started');
            }

            log(message) {
                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';
                const timestamp = new Date().toLocaleTimeString();
                logEntry.textContent = `[${timestamp}] ${message}`;
                
                const gameLog = document.getElementById('game-log');
                gameLog.appendChild(logEntry);
                gameLog.scrollTop = gameLog.scrollHeight;
            }

            setupBoard() {
                // Setup pawns
                for (let i = 0; i < 8; i++) {
                    this.board[1][i] = { type: 'PAWN', color: 'BLACK', hasMoved: false };
                    this.board[6][i] = { type: 'PAWN', color: 'WHITE', hasMoved: false };
                }

                // Setup other pieces
                const backrow = ['ROOK', 'KNIGHT', 'BISHOP', 'QUEEN', 'KING', 'BISHOP', 'KNIGHT', 'ROOK'];
                backrow.forEach((piece, i) => {
                    this.board[0][i] = { type: piece, color: 'BLACK', hasMoved: false };
                    this.board[7][i] = { type: piece, color: 'WHITE', hasMoved: false };
                });
            }

            isValidMove(startRow, startCol, endRow, endCol) {
                // Add boundary checks
                if (!this.isValidPosition(startRow, startCol) || !this.isValidPosition(endRow, endCol)) {
                    return false;
                }
                
                const piece = this.board[startRow][startCol];
                if (!piece || piece.color !== this.currentPlayer) return false;

                switch (piece.type) {
                    case 'PAWN':
                        return this.isValidPawnMove(startRow, startCol, endRow, endCol);
                    case 'ROOK':
                        return this.isValidRookMove(startRow, startCol, endRow, endCol);
                    case 'KNIGHT':
                        return this.isValidKnightMove(startRow, startCol, endRow, endCol);
                    case 'BISHOP':
                        return this.isValidBishopMove(startRow, startCol, endRow, endCol);
                    case 'QUEEN':
                        return this.isValidQueenMove(startRow, startCol, endRow, endCol);
                    case 'KING':
                        return this.isValidKingMove(startRow, startCol, endRow, endCol);
                }
                return false;
            }

            // Add this new helper method after constructor
            isValidPosition(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }

            isValidPawnMove(startRow, startCol, endRow, endCol) {
                const piece = this.board[startRow][startCol];
                const direction = piece.color === 'WHITE' ? -1 : 1;
                const startingRow = piece.color === 'WHITE' ? 6 : 1;

                // Regular move
                if (startCol === endCol && this.board[endRow][endCol] === null) {
                    if (endRow === startRow + direction) return true;
                    if (startRow === startingRow && endRow === startRow + 2 * direction && 
                        this.board[startRow + direction][startCol] === null) return true;
                }

                // Regular capture
                if (Math.abs(startCol - endCol) === 1 && endRow === startRow + direction) {
                    // Normal capture
                    if (this.board[endRow][endCol] && 
                        this.board[endRow][endCol].color !== piece.color) return true;
                    
                    // En passant capture
                    if (this.lastPawnDoubleMove && 
                        this.lastPawnDoubleMove.row === startRow &&
                        this.lastPawnDoubleMove.col === endCol) {
                        return true;
                    }
                }

                return false;
            }

            isValidRookMove(startRow, startCol, endRow, endCol) {
                if (startRow !== endRow && startCol !== endCol) return false;
                return this.isPathClear(startRow, startCol, endRow, endCol);
            }

            isValidKnightMove(startRow, startCol, endRow, endCol) {
                const rowDiff = Math.abs(startRow - endRow);
                const colDiff = Math.abs(startCol - endCol);
                return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
            }

            isValidBishopMove(startRow, startCol, endRow, endCol) {
                if (Math.abs(startRow - endRow) !== Math.abs(startCol - endCol)) return false;
                return this.isPathClear(startRow, startCol, endRow, endCol);
            }

            isValidQueenMove(startRow, startCol, endRow, endCol) {
                return this.isValidRookMove(startRow, startCol, endRow, endCol) ||
                       this.isValidBishopMove(startRow, startCol, endRow, endCol);
            }

            isValidKingMove(startRow, startCol, endRow, endCol) {
                // Regular king move
                if (Math.abs(startRow - endRow) <= 1 && Math.abs(startCol - endCol) <= 1) {
                    return true;
                }
                
                // Check for castling
                const piece = this.board[startRow][startCol];
                if (!piece.hasMoved && startRow === endRow && Math.abs(startCol - endCol) === 2) {
                    return this.isValidCastling(startRow, startCol, endRow, endCol);
                }
                
                return false;
            }

            isValidCastling(startRow, startCol, endRow, endCol) {
                const direction = endCol > startCol ? 1 : -1;
                const rookCol = direction === 1 ? 7 : 0;
                const rook = this.board[startRow][rookCol];
                const kingColor = this.board[startRow][startCol].color;
                const oppositeColor = kingColor === 'WHITE' ? 'BLACK' : 'WHITE';

                // Cannot castle while in check
                if (this.isInCheck(kingColor)) {
                    console.log('Cannot castle while in check');
                    return false;
                }

                // Check if rook exists and hasn't moved
                if (!rook || rook.type !== 'ROOK' || rook.hasMoved) {
                    console.log('Invalid rook state for castling');
                    return false;
                }

                // Check if path is clear and king doesn't pass through attacked squares
                const pathStart = startCol;
                const pathEnd = direction === 1 ? startCol + 2 : startCol - 2;
                const step = direction;

                // Check each square in the king's path
                for (let col = pathStart; direction === 1 ? col <= pathEnd : col >= pathEnd; col += step) {
                    // Skip checking occupancy of starting square
                    if (col !== startCol && this.board[startRow][col] !== null) {
                        console.log('Path is blocked for castling');
                        return false;
                    }
                    // Check if square is under attack (including starting and ending squares)
                    if (this.isSquareUnderAttack(startRow, col, oppositeColor)) {
                        console.log(`Square ${startRow},${col} is under attack`);
                        return false;
                    }
                }

                return true;
            }

            isPathClear(startRow, startCol, endRow, endCol) {
                const rowDir = startRow === endRow ? 0 : (endRow - startRow) / Math.abs(endRow - startRow);
                const colDir = startCol === endCol ? 0 : (endCol - startCol) / Math.abs(endCol - startCol);
                let row = startRow + rowDir;
                let col = startCol + colDir;

                while (row !== endRow || col !== endCol) {
                    if (this.board[row][col] !== null) return false;
                    row += rowDir;
                    col += colDir;
                }

                return true;
            }

            findKing(color) {
                let kingFound = false;
                let kingPosition = null;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.type === 'KING' && piece.color === color) {
                            if (kingFound) {
                                console.error('Multiple kings found for', color);
                            }
                            kingFound = true;
                            kingPosition = { row, col };
                        }
                    }
                }
                
                if (!kingFound) {
                    console.error(`King not found for ${color}`);
                }
                
                return kingPosition;
            }

            isSquareUnderAttack(row, col, byColor) {
                for (let startRow = 0; startRow < 8; startRow++) {
                    for (let startCol = 0; startCol < 8; startCol++) {
                        const piece = this.board[startRow][startCol];
                        if (piece && piece.color === byColor) {
                            // Temporarily set attacking color as current player to check move validity
                            const savedPlayer = this.currentPlayer;
                            this.currentPlayer = byColor;
                            const isValid = this.isValidMove(startRow, startCol, row, col);
                            this.currentPlayer = savedPlayer;
                            if (isValid) return true;
                        }
                    }
                }
                return false;
            }

            isInCheck(color) {
                const king = this.findKing(color);
                if (!king) {
                    console.error('King not found for', color, 'current board state:', this.board);
                    return false;
                }
                const oppositeColor = color === 'WHITE' ? 'BLACK' : 'WHITE';
                return this.isSquareUnderAttack(king.row, king.col, oppositeColor);
            }

            evaluateMove(startRow, startCol, endRow, endCol, color) {
                const piece = this.board[startRow][startCol];
                if (!piece || piece.color !== color) return false;

                // Prevent capturing kings during evaluation
                const targetPiece = this.board[endRow][endCol];
                if (targetPiece && targetPiece.type === 'KING') return false;

                // Try the move
                const savedTarget = this.board[endRow][endCol];
                const savedLastPawnMove = this.lastPawnDoubleMove;
                this.board[endRow][endCol] = { ...piece };
                this.board[startRow][startCol] = null;

                // Check if this move would leave or put king in check
                const movePutsInCheck = this.isInCheck(color);

                // Restore the board
                this.board[startRow][startCol] = piece;
                this.board[endRow][endCol] = savedTarget;
                this.lastPawnDoubleMove = savedLastPawnMove;

                return !movePutsInCheck;
            }

            hasLegalMoves(color) {
                if (color === this.currentPlayer) {
                    return this.validMovesCache.size > 0;
                }
                // Fall back to computation for non-current player
                return super.hasLegalMoves(color);
            }

            movePiece(startRow, startCol, endRow, endCol) {
                const piece = this.board[startRow][startCol];
                
                if (!this.isValidMove(startRow, startCol, endRow, endCol)) {
                    this.log('Invalid move attempted');
                    return false;
                }

                const targetSquare = this.board[endRow][endCol];
                if (targetSquare && targetSquare.color === piece.color) return false;
                
                // Don't allow moving the last king
                if (piece.type === 'KING') {
                    const oppositeColor = piece.color === 'WHITE' ? 'BLACK' : 'WHITE';
                    if (!this.findKing(oppositeColor)) {
                        console.error('Cannot move last remaining king');
                        return false;
                    }
                }

                // Make temporary move to check for king safety
                const savedPiece = { ...piece };
                const savedTarget = this.board[endRow][endCol];
                const savedLastPawnMove = this.lastPawnDoubleMove;
                
                this.board[endRow][endCol] = savedPiece;
                this.board[startRow][startCol] = null;

                // Verify both kings are still on board and check for check
                const whiteKing = this.findKing('WHITE');
                const blackKing = this.findKing('BLACK');
                const movePutsOwnKingInCheck = this.isInCheck(piece.color);
                
                // Restore board state
                this.board[startRow][startCol] = piece;
                this.board[endRow][endCol] = savedTarget;
                this.lastPawnDoubleMove = savedLastPawnMove;

                if (!whiteKing || !blackKing) {
                    console.error('Invalid move - would remove king from board');
                    return false;
                }

                if (movePutsOwnKingInCheck) {
                    console.log('Move puts own king in check');
                    return false;
                }

                // Reset last pawn double move
                this.lastPawnDoubleMove = null;

                // Handle special moves
                if (piece.type === 'PAWN') {
                    // Handle pawn double move
                    if (Math.abs(startRow - endRow) === 2) {
                        this.lastPawnDoubleMove = { row: endRow, col: endCol };
                    }
                    // Handle en passant capture
                    else if (Math.abs(startCol - endCol) === 1 && !targetSquare) {
                        this.board[startRow][endCol] = null;
                    }
                    // Handle promotion
                    if (endRow === 0 || endRow === 7) {
                        this.board[endRow][endCol] = { type: 'QUEEN', color: piece.color, hasMoved: true };
                        this.board[startRow][startCol] = null;
                        // Skip the normal move as we've handled it
                        this.afterMove(piece);
                        return true;
                    }
                }
                // Handle castling
                else if (piece.type === 'KING' && Math.abs(startCol - endCol) === 2) {
                    const direction = endCol > startCol ? 1 : -1;
                    const rookCol = direction === 1 ? 7 : 0;
                    const newRookCol = direction === 1 ? endCol - 1 : endCol + 1;
                    
                    const rook = { ...this.board[startRow][rookCol] };
                    this.board[endRow][newRookCol] = { ...rook, hasMoved: true };
                    this.board[startRow][rookCol] = null;
                }

                // Make the actual move
                this.board[endRow][endCol] = { ...piece, hasMoved: true };
                this.board[startRow][startCol] = null;

                this.afterMove(piece);
                return true;
            }

            afterMove(piece) {
                const previousPlayer = this.currentPlayer;
                this.currentPlayer = this.currentPlayer === 'WHITE' ? 'BLACK' : 'WHITE';
                this.computeAllValidMoves(); // Compute valid moves for next player
                
                // Check game state
                const inCheck = this.isInCheck(this.currentPlayer);
                const hasLegalMoves = this.hasLegalMoves(this.currentPlayer);
                
                // Update game status
                const status = document.getElementById('status');
                
                if (inCheck && !hasLegalMoves) {
                    // Checkmate
                    status.textContent = `Checkmate! ${piece.color} wins!`;
                    this.log(`Checkmate! ${piece.color} wins!`);
                    this.gameOver = true;
                } else if (inCheck) {
                    // Check
                    status.textContent = `${this.currentPlayer} is in check!`;
                    this.log(`${this.currentPlayer} is in check!`);
                } else if (!hasLegalMoves) {
                    // Stalemate
                    status.textContent = 'Stalemate! Game is a draw.';
                    this.log('Stalemate! Game is a draw.');
                    this.gameOver = true;
                } else {
                    status.textContent = '';
                }

                // Update turn display while keeping spinner hidden by default
                const turnElement = document.getElementById('turn');
                turnElement.innerHTML = `${this.currentPlayer}'s turn<div id="ai-spinner" class="spinner"></div>`;
                // Hide spinner immediately after creating it
                document.getElementById('ai-spinner').style.display = 'none';
                
                // Render immediately after white's move
                this.renderBoard();
                
                if (this.currentPlayer === 'BLACK' && !this.gameOver) {
                    this.makeAIMove();
                }
            }

            computeAllValidMoves() {
                this.validMovesCache.clear();
                
                for (let startRow = 0; startRow < 8; startRow++) {
                    for (let startCol = 0; startCol < 8; startCol++) {
                        const piece = this.board[startRow][startCol];
                        if (!piece || piece.color !== this.currentPlayer) continue;

                        const key = `${startRow},${startCol}`;
                        const validMoves = [];

                        for (let endRow = 0; endRow < 8; endRow++) {
                            for (let endCol = 0; endCol < 8; endCol++) {
                                // Skip if destination has friendly piece
                                const targetPiece = this.board[endRow][endCol];
                                if (targetPiece && targetPiece.color === this.currentPlayer) {
                                    continue;
                                }

                                if (this.isValidMove(startRow, startCol, endRow, endCol) &&
                                    this.evaluateMove(startRow, startCol, endRow, endCol, this.currentPlayer)) {
                                    validMoves.push({ row: endRow, col: endCol });
                                }
                            }
                        }

                        if (validMoves.length > 0) {
                            this.validMovesCache.set(key, validMoves);
                        }
                    }
                }
            }

            getValidMovesForPiece(row, col) {
                const key = `${row},${col}`;
                return this.validMovesCache.get(key) || [];
            }

            renderBoard() {
                const boardElement = document.getElementById('board');
                boardElement.innerHTML = '';

                // Get valid moves if a piece is selected
                const validMoves = this.selectedPiece ? 
                    this.getValidMovesForPiece(this.selectedPiece.row, this.selectedPiece.col) : [];

                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 ? 'black' : 'white'}`;
                        
                        const piece = this.board[row][col];
                        
                        // Highlight valid moves
                        const isValidMove = validMoves.some(move => move.row === row && move.col === col);
                        if (isValidMove) {
                            square.classList.add('valid-move');
                            // Add special highlighting for captures
                            if (piece && piece.color !== this.currentPlayer) {
                                square.classList.add('valid-capture');
                            }
                        }

                        // Highlight selected piece
                        if (this.selectedPiece && 
                            row === this.selectedPiece.row && 
                            col === this.selectedPiece.col) {
                            square.classList.add('selected');
                        }

                        if (piece) {
                            const pieceSpan = document.createElement('span');
                            pieceSpan.className = `${piece.color.toLowerCase()}-piece`;
                            pieceSpan.textContent = PIECES[piece.color][piece.type];
                            square.appendChild(pieceSpan);
                        }

                        square.dataset.row = row;
                        square.dataset.col = col;
                        square.addEventListener('click', this.handleSquareClick.bind(this));
                        boardElement.appendChild(square);
                    }
                }
            }

            handleSquareClick(event) {
                if (this.gameOver) {
                    this.log('Game is already over');
                    return;
                }

                // Get row and col from clicked element or its parent
                let row, col;
                if (event.target.dataset.row) {
                    row = parseInt(event.target.dataset.row);
                    col = parseInt(event.target.dataset.col);
                } else if (event.target.parentElement.dataset.row) {
                    row = parseInt(event.target.parentElement.dataset.row);
                    col = parseInt(event.target.parentElement.dataset.col);
                } else {
                    return; // Invalid click target
                }

                // Validate position
                if (!this.isValidPosition(row, col)) {
                    return;
                }

                const piece = this.board[row][col];

                // Clicking on an already selected piece
                if (this.selectedPiece && 
                    this.selectedPiece.row === row && 
                    this.selectedPiece.col === col) {
                    this.selectedPiece = null;
                    this.renderBoard();
                    return;
                }

                // Clicking on a valid move for selected piece
                if (this.selectedPiece) {
                    const validMoves = this.getValidMovesForPiece(this.selectedPiece.row, this.selectedPiece.col);
                    const isValidMove = validMoves.some(move => move.row === row && move.col === col);

                    if (isValidMove) {
                        this.movePiece(this.selectedPiece.row, this.selectedPiece.col, row, col);
                        this.selectedPiece = null;
                        this.renderBoard();
                        return;
                    }
                }

                // Selecting a new piece
                if (piece && piece.color === this.currentPlayer) {
                    this.selectedPiece = { row, col };
                    this.renderBoard();
                }
            }

            evaluatePosition(color) {
                const pieceValues = {
                    'PAWN': 100,
                    'KNIGHT': 320,
                    'BISHOP': 330,
                    'ROOK': 500,
                    'QUEEN': 900,
                    'KING': 20000
                };

                // Positional bonuses for pieces
                const pawnPositionBonus = [
                    [0,  0,  0,  0,  0,  0,  0,  0],
                    [50, 50, 50, 50, 50, 50, 50, 50],
                    [10, 10, 20, 30, 30, 20, 10, 10],
                    [5,  5, 10, 25, 25, 10,  5,  5],
                    [0,  0,  0, 20, 20,  0,  0,  0],
                    [5, -5,-10,  0,  0,-10, -5,  5],
                    [5, 10, 10,-20,-20, 10, 10,  5],
                    [0,  0,  0,  0,  0,  0,  0,  0]
                ];

                let score = 0;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece) {
                            // Material value
                            let value = pieceValues[piece.type];
                            
                            // Position value
                            if (piece.type === 'PAWN') {
                                const positionRow = piece.color === 'WHITE' ? row : 7 - row;
                                value += pawnPositionBonus[positionRow][col];
                            }

                            // Center control bonus for minor pieces
                            if (['KNIGHT', 'BISHOP'].includes(piece.type)) {
                                if ((row === 3 || row === 4) && (col === 3 || col === 4)) {
                                    value += 10;
                                }
                            }

                            score += value * (piece.color === color ? 1 : -1);
                        }
                    }
                }
                return score;
            }

            minimax(depth, alpha, beta, maximizingPlayer) {
                // Check for leaf node
                if (depth === 0) {
                    return this.evaluatePosition('BLACK');
                }

                const currentColor = maximizingPlayer ? 'BLACK' : 'WHITE';
                const savedPlayer = this.currentPlayer;
                this.currentPlayer = currentColor;

                let bestScore = maximizingPlayer ? -Infinity : Infinity;
                
                for (let startRow = 0; startRow < 8; startRow++) {
                    for (let startCol = 0; startCol < 8; startCol++) {
                        const piece = this.board[startRow][startCol];
                        if (!piece || piece.color !== currentColor) continue;

                        for (let endRow = 0; endRow < 8; endRow++) {
                            for (let endCol = 0; endCol < 8; endCol++) {
                                if (this.isValidMove(startRow, startCol, endRow, endCol) &&
                                    this.evaluateMove(startRow, startCol, endRow, endCol, currentColor)) {
                                    
                                    // Make move
                                    const savedTarget = this.board[endRow][endCol];
                                    this.board[endRow][endCol] = piece;
                                    this.board[startRow][startCol] = null;

                                    const score = this.minimax(depth - 1, alpha, beta, !maximizingPlayer);

                                    // Undo move
                                    this.board[startRow][startCol] = piece;
                                    this.board[endRow][endCol] = savedTarget;

                                    if (maximizingPlayer) {
                                        bestScore = Math.max(bestScore, score);
                                        alpha = Math.max(alpha, score);
                                    } else {
                                        bestScore = Math.min(bestScore, score);
                                        beta = Math.min(beta, score);
                                    }

                                    if (beta <= alpha) {
                                        this.currentPlayer = savedPlayer;
                                        return bestScore;
                                    }
                                }
                            }
                        }
                    }
                }

                this.currentPlayer = savedPlayer;
                return bestScore;
            }

            findBestMove() {
                let bestScore = -Infinity;
                let bestMove = null;
                const depth = this.searchDepth; // Use configurable depth
                
                const savedPlayer = this.currentPlayer;
                this.currentPlayer = 'BLACK';

                for (let startRow = 0; startRow < 8; startRow++) {
                    for (let startCol = 0; startCol < 8; startCol++) {
                        const piece = this.board[startRow][startCol];
                        if (!piece || piece.color !== 'BLACK') continue;

                        for (let endRow = 0; endRow < 8; endRow++) {
                            for (let endCol = 0; endCol < 8; endCol++) {
                                if (this.isValidMove(startRow, startCol, endRow, endCol) &&
                                    this.evaluateMove(startRow, startCol, endRow, endCol, 'BLACK')) {
                                    
                                    const savedTarget = this.board[endRow][endCol];
                                    this.board[endRow][endCol] = piece;
                                    this.board[startRow][startCol] = null;

                                    const score = this.minimax(depth - 1, -Infinity, Infinity, false);

                                    this.board[startRow][startCol] = piece;
                                    this.board[endRow][endCol] = savedTarget;

                                    if (score > bestScore) {
                                        bestScore = score;
                                        bestMove = { startRow, startCol, endRow, endCol };
                                    }
                                }
                            }
                        }
                    }
                }

                this.currentPlayer = savedPlayer;
                return bestMove;
            }

            makeAIMove() {
                if (!this.isAIEnabled || this.currentPlayer !== 'BLACK' || this.gameOver) return;
                
                // Show spinner
                const spinner = document.getElementById('ai-spinner');
                spinner.style.display = 'inline-block';
                
                // Use setTimeout to ensure board renders before heavy calculation
                setTimeout(() => {
                    const move = this.findBestMove();
                    if (move) {
                        this.movePiece(move.startRow, move.startCol, move.endRow, move.endCol);
                        this.renderBoard();
                    }
                    spinner.style.display = 'none';
                }, 50); // Small delay to allow board to render
            }

            initializeControls() {
                const slider = document.getElementById('depth-slider');
                const depthValue = document.getElementById('depth-value');
                
                slider.addEventListener('input', (e) => {
                    this.searchDepth = parseInt(e.target.value);
                    depthValue.textContent = this.searchDepth;
                });
            }

        }

        const game = new Chess();
    </script>
</body>
</html>
