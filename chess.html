<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Chess Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #0a0a0f;
            font-family: 'Roboto', sans-serif;
            display: flex;
            justify-content: center;
            min-height: 100vh;
            /* color: #00ff00; */
        }

        .game-container {
            display: flex;
            gap: 30px;
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px;
            gap: 20px;
            width: 100%;
        }

        .game-left {
            flex: 1;
            max-width: 400px;
        }

        .game-right {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .board {
            width: 100%;
            max-width: 400px;
            height: auto;
            aspect-ratio: 1;
            margin: 0 auto;
            border-radius: 4px;
            box-shadow: 0 0 20px #ff00ff, 0 0 40px #ff00ff80;
            overflow: hidden;
            background: #1a1a2e;
            display: grid;
            grid-template: repeat(8, 1fr) / repeat(8, 1fr);
            border: 2px solid #ff00ff;
        }

        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: min(5vw, 2.2em);
            cursor: pointer;
            transition: all 0.2s ease;
            text-shadow: none; /* Remove existing text shadow */
            position: relative;
        }

        /* White pieces get cyan glow */
        .square:has(span.white-piece) {
            color: #fff;
            text-shadow: 0 0 10px #00ffff,
                        0 0 20px #00ffff,
                        0 0 30px #00ffff;
        }

        /* Black pieces get magenta glow */
        .square:has(span.black-piece) {
            color: #ffffff;
            text-shadow: 0 0 10px #ffffff,
                        0 0 20px #000000,
                        0 0 30px #000000;
        }

        .white-piece {
            color: #fff;
            filter: brightness(1.2);
        }

        .black-piece {
            color: #000000;
            filter: brightness(1.2);
        }

        /* Enhance selected piece glow */
        .selected:has(span.white-piece) {
            background: #103040 !important;
            box-shadow: inset 0 0 30px #00ffff;
        }

        .selected:has(span.black-piece) {
            background: #401040 !important;
            box-shadow: inset 0 0 30px #ff00ff;
        }

        .square:hover {
            transform: scale(1.05);
            z-index: 1;
            box-shadow: inset 0 0 20px #00ffff80;
        }

        .white { background: #1a1a2e; }
        .black { background: #2a2a4e; }
        
        .selected { 
            background: #4a1a4e !important;
            box-shadow: inset 0 0 30px #ff00ff;
            text-shadow: 0 0 15px #ff00ff;
        }

        .valid-move::after {
            content: '';
            position: absolute;
            width: 25px;
            height: 25px;
            background: #00ffff40;
            border: 2px solid #00ffff;
            border-radius: 50%;
            box-shadow: 0 0 10px #00ffff;
            opacity: 0.8;
            transition: all 0.2s ease;
        }

        .valid-capture::after {
            border: 2px solid #ff00ff;
            background: #ff00ff40;
            box-shadow: 0 0 10px #ff00ff;
        }

        .game-info {
            background: #1a1a2e;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px #00ffff80;
            border: 1px solid #00ffff;
        }

        #turn {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            font-size: 1.5em;
            font-weight: 500;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            margin-bottom: 10px;
        }

        .turn-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .move-counter {
            color: #ff00ff;
            font-size: 0.9em;
            text-shadow: 0 0 10px #ff00ff;
        }

        #status {
            font-size: 1.2em;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
            font-weight: 300;
        }

        .game-log {
            background: #1a1a2e;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px #00ffff80;
            border: 1px solid #00ffff;
            max-height: 300px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 8px;
            border-bottom: 1px solid #2a2a4e;
            color: #00ffff;
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .move-number {
            color: #ff00ff;
            margin-right: 10px;
        }

        .move-text {
            font-family: monospace;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            
            .game-right {
                width: 100%;
                max-width: 400px;
            }

            body {
                padding: 10px;
            }

            .game-container {
                flex-direction: column;
            }
            
            .game-left, .game-right {
                width: 100%;
                max-width: 100%;
            }

            .difficulty-control, .game-info, .game-log {
                margin-bottom: 10px;
                padding: 15px;
            }

            .game-log {
                max-height: 200px;
            }

            #turn {
                font-size: 1.2em;
            }

            .difficulty-label {
                font-size: 1em;
            }
        }

        @media (max-width: 480px) {
            .square {
                font-size: 6vw;
            }

            .game-log {
                max-height: 150px;
            }
        }

        .spinner {
            display: none;  /* Changed from display: inline-block */
            width: 20px;
            height: 20px;
            border: 3px solid #1a1a2e;
            border-top: 3px solid #00ffff;
            border-radius: 50%;
            margin-left: 10px;
            animation: spin 1s linear infinite;
            vertical-align: middle;
            box-shadow: 0 0 15px #00ffff;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .difficulty-control {
            background: #1a1a2e;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px #00ffff80;
            border: 1px solid #00ffff;
            margin-bottom: 20px;
        }

        .difficulty-slider {
            width: 100%;
            margin: 10px 0;
            appearance: none;
            height: 4px;
            background: #2a2a4e;
            border-radius: 2px;
            outline: none;
        }

        .difficulty-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: #ff00ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 15px #ff00ff;
        }

        .difficulty-label {
            font-size: 1.1em;
            color: #00ffff;
            display: flex;
            justify-content: space-between;
            align-items: center;
            text-shadow: 0 0 5px #00ffff;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: #1a1a2e;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            border: 2px solid #00ffff;
            box-shadow: 0 0 30px #00ffff80;
            animation: modalAppear 0.3s ease-out;
            position: relative;
        }

        @keyframes modalAppear {
            from {
                transform: scale(0.8);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .modal h2 {
            color: #00ffff;
            margin: 0 0 20px 0;
            text-shadow: 0 0 10px #00ffff;
        }

        .modal p {
            color: #ffffff;
            margin: 0 0 30px 0;
            font-size: 1.2em;
        }

        .modal-button {
            background: #00ffff;
            color: #1a1a2e;
            border: none;
            padding: 10px 30px;
            border-radius: 5px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-button:hover {
            background: #ff00ff;
            box-shadow: 0 0 15px #ff00ff;
            transform: scale(1.05);
        }

        /* Add new CSS for dangerous moves */
        .valid-move.dangerous::after {
            border: 2px solid #ff0000;
            background: #ff000040;
            box-shadow: 0 0 10px #ff0000;
        }

        .valid-capture.dangerous::after {
            border: 2px solid #ff0000;
            background: #ff000040;
            box-shadow: 0 0 10px #ff0000;
        }

        .modal-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: #00ffff;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.2s ease;
            padding: 5px;
            line-height: 0.8;
            border-radius: 50%;
        }

        .modal-close:hover {
            color: #ff00ff;
            transform: scale(1.1);
        }

        .modal-content {
            position: relative;
            /* ...existing modal-content styles... */
        }

        .valid-move.checkmate::after {
            border: 2px solid #00ff00;
            background: #00ff0040;
            box-shadow: 0 0 10px #00ff00;
        }

        .valid-capture.checkmate::after {
            border: 2px solid #00ff00;
            background: #00ff0040;
            box-shadow: 0 0 10px #00ff00;
        }

        .control-buttons {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .control-button {
            background: #1a1a2e;
            color: #00ffff;
            border: 1px solid #00ffff;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }

        .control-button:hover {
            background: #2a2a4e;
            box-shadow: 0 0 10px #00ffff;
            transform: scale(1.05);
        }

        .control-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-left">
            <div class="difficulty-control">
                <div class="difficulty-label">
                    <span>AI Difficulty:</span>
                    <span id="depth-value">3</span>
                </div>
                <input type="range" min="1" max="5" value="3" class="difficulty-slider" id="depth-slider">
                <div class="control-buttons">
                    <button id="revertButton" class="control-button" disabled>Revert Move</button>
                </div>
            </div>
            <div class="board" id="board"></div>
        </div>
        <div class="game-right">
            <div class="game-info">
                <div id="turn">
                    <div class="turn-info">
                        <span>White's turn</span>
                        <div id="ai-spinner" class="spinner"></div>
                    </div>
                    <span class="move-counter">Move: 1</span>
                </div>
                <div id="status"></div>
            </div>
            <div class="game-log" id="game-log"></div>
        </div>
    </div>

    <div id="checkmateModal" class="modal">
        <div class="modal-content">
            <button class="modal-close" onclick="document.getElementById('checkmateModal').classList.remove('show')">×</button>
            <h2>Game Over!</h2>
            <p id="modalMessage"></p>
            <button class="modal-button" onclick="location.reload()">Play Again</button>
        </div>
    </div>

    <script>
        const PIECES = {
            WHITE: {
                KING: '♔', QUEEN: '♕', ROOK: '♖',
                BISHOP: '♗', KNIGHT: '♘', PAWN: '♙'
            },
            BLACK: {
                KING: '♚', QUEEN: '♛', ROOK: '♜',
                BISHOP: '♝', KNIGHT: '♞', PAWN: '♟'
            }
        };

        class Chess {
            constructor() {
                this.board = Array(8).fill().map(() => Array(8).fill(null));
                this.selectedPiece = null;
                this.currentPlayer = 'WHITE';
                this.validMoves = [];
                this.lastPawnDoubleMove = null; // Add this line
                this.setupBoard();
                this.renderBoard();
                this.gameOver = false; // Add this line
                this.moveHistory = [];
                this.initializeLogging();
                this.validMovesCache = new Map(); // Add cache for valid moves
                this.computeAllValidMoves(); // Initial computation
                this.isAIEnabled = true; // Add this line
                this.searchDepth = 3; // Add default search depth
                this.initializeControls(); // Add this line
                this.moveCounter = 1; // Full moves (each player's turn = 1 move)
                this.halfMoveCounter = 1; // Individual turns
                this.positionHistory = new Map(); // Add position history tracking
                this.moveNotation = [];
                this.moveStack = []; // Add this line to store move history
            }

            initializeLogging() {
                this.log('Game started');
            }

            log(message, moveNotation = null) {
                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';

                if (moveNotation) {
                    const moveNumber = Math.ceil(this.halfMoveCounter / 2);
                    const isWhiteMove = this.halfMoveCounter % 2 === 1;

                    const moveNumberSpan = document.createElement('span');
                    moveNumberSpan.className = 'move-number';
                    moveNumberSpan.textContent = `${moveNumber}.${isWhiteMove ? '' : '..'}`;

                    const moveTextSpan = document.createElement('span');
                    moveTextSpan.className = 'move-text';
                    moveTextSpan.textContent = moveNotation;

                    logEntry.appendChild(moveNumberSpan);
                    logEntry.appendChild(moveTextSpan);

                    this.moveNotation.push(moveNotation);
                } else {
                    logEntry.textContent = message;
                }

                const gameLog = document.getElementById('game-log');
                gameLog.appendChild(logEntry);
                gameLog.scrollTop = gameLog.scrollHeight;
            }

            setupBoard() {
                // Setup pawns
                for (let i = 0; i < 8; i++) {
                    this.board[1][i] = { type: 'PAWN', color: 'BLACK', hasMoved: false };
                    this.board[6][i] = { type: 'PAWN', color: 'WHITE', hasMoved: false };
                }

                // Setup other pieces
                const backrow = ['ROOK', 'KNIGHT', 'BISHOP', 'QUEEN', 'KING', 'BISHOP', 'KNIGHT', 'ROOK'];
                backrow.forEach((piece, i) => {
                    this.board[0][i] = { type: piece, color: 'BLACK', hasMoved: false };
                    this.board[7][i] = { type: piece, color: 'WHITE', hasMoved: false };
                });
            }

            isValidMove(startRow, startCol, endRow, endCol) {
                // Add boundary checks
                if (!this.isValidPosition(startRow, startCol) || !this.isValidPosition(endRow, endCol)) {
                    return false;
                }
                
                const piece = this.board[startRow][startCol];
                if (!piece || piece.color !== this.currentPlayer) return false;

                switch (piece.type) {
                    case 'PAWN':
                        return this.isValidPawnMove(startRow, startCol, endRow, endCol);
                    case 'ROOK':
                        return this.isValidRookMove(startRow, startCol, endRow, endCol);
                    case 'KNIGHT':
                        return this.isValidKnightMove(startRow, startCol, endRow, endCol);
                    case 'BISHOP':
                        return this.isValidBishopMove(startRow, startCol, endRow, endCol);
                    case 'QUEEN':
                        return this.isValidQueenMove(startRow, startCol, endRow, endCol);
                    case 'KING':
                        return this.isValidKingMove(startRow, startCol, endRow, endCol);
                }
                return false;
            }

            // Add this new helper method after constructor
            isValidPosition(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }

            isValidPawnMove(startRow, startCol, endRow, endCol) {
                const piece = this.board[startRow][startCol];
                const direction = piece.color === 'WHITE' ? -1 : 1;
                const startingRow = piece.color === 'WHITE' ? 6 : 1;

                // Regular move
                if (startCol === endCol && this.board[endRow][endCol] === null) {
                    if (endRow === startRow + direction) return true;
                    if (startRow === startingRow && endRow === startRow + 2 * direction && 
                        this.board[startRow + direction][startCol] === null) return true;
                }

                // Regular capture
                if (Math.abs(startCol - endCol) === 1 && endRow === startRow + direction) {
                    // Normal capture
                    if (this.board[endRow][endCol] && 
                        this.board[endRow][endCol].color !== piece.color) return true;
                    
                    // En passant capture
                    if (this.lastPawnDoubleMove && 
                        this.lastPawnDoubleMove.row === startRow &&
                        this.lastPawnDoubleMove.col === endCol) {
                        return true;
                    }
                }

                return false;
            }

            isValidRookMove(startRow, startCol, endRow, endCol) {
                if (startRow !== endRow && startCol !== endCol) return false;
                return this.isPathClear(startRow, startCol, endRow, endCol);
            }

            isValidKnightMove(startRow, startCol, endRow, endCol) {
                const rowDiff = Math.abs(startRow - endRow);
                const colDiff = Math.abs(startCol - endCol);
                return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
            }

            isValidBishopMove(startRow, startCol, endRow, endCol) {
                if (Math.abs(startRow - endRow) !== Math.abs(startCol - endCol)) return false;
                return this.isPathClear(startRow, startCol, endRow, endCol);
            }

            isValidQueenMove(startRow, startCol, endRow, endCol) {
                return this.isValidRookMove(startRow, startCol, endRow, endCol) ||
                       this.isValidBishopMove(startRow, startCol, endRow, endCol);
            }

            isValidKingMove(startRow, startCol, endRow, endCol) {
                // Regular king move
                if (Math.abs(startRow - endRow) <= 1 && Math.abs(startCol - endCol) <= 1) {
                    return true;
                }
                
                // Check for castling
                const piece = this.board[startRow][startCol];
                if (!piece.hasMoved && startRow === endRow && Math.abs(startCol - endCol) === 2) {
                    return this.isValidCastling(startRow, startCol, endRow, endCol);
                }
                
                return false;
            }

            isValidCastling(startRow, startCol, endRow, endCol) {
                const direction = endCol > startCol ? 1 : -1;
                const rookCol = direction === 1 ? 7 : 0;
                const rook = this.board[startRow][rookCol];
                const kingColor = this.board[startRow][startCol].color;
                const oppositeColor = kingColor === 'WHITE' ? 'BLACK' : 'WHITE';

                // Cannot castle while in check
                if (this.isInCheck(kingColor)) {
                    console.log('Cannot castle while in check');
                    return false;
                }

                // Check if rook exists and hasn't moved
                if (!rook || rook.type !== 'ROOK' || rook.hasMoved) {
                    console.log('Invalid rook state for castling');
                    return false;
                }

                // Check if path is clear and king doesn't pass through attacked squares
                const pathStart = startCol;
                const pathEnd = direction === 1 ? startCol + 2 : startCol - 2;
                const step = direction;

                // Check each square in the king's path
                for (let col = pathStart; direction === 1 ? col <= pathEnd : col >= pathEnd; col += step) {
                    // Skip checking occupancy of starting square
                    if (col !== startCol && this.board[startRow][col] !== null) {
                        console.log('Path is blocked for castling');
                        return false;
                    }
                    // Check if square is under attack (including starting and ending squares)
                    if (this.isSquareUnderAttack(startRow, col, oppositeColor)) {
                        console.log(`Square ${startRow},${col} is under attack`);
                        return false;
                    }
                }

                return true;
            }

            isPathClear(startRow, startCol, endRow, endCol) {
                const rowDir = startRow === endRow ? 0 : (endRow - startRow) / Math.abs(endRow - startRow);
                const colDir = startCol === endCol ? 0 : (endCol - startCol) / Math.abs(endCol - startCol);
                let row = startRow + rowDir;
                let col = startCol + colDir;

                while (row !== endRow || col !== endCol) {
                    if (this.board[row][col] !== null) return false;
                    row += rowDir;
                    col += colDir;
                }

                return true;
            }

            findKing(color) {
                let kingFound = false;
                let kingPosition = null;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.type === 'KING' && piece.color === color) {
                            if (kingFound) {
                                console.error('Multiple kings found for', color);
                            }
                            kingFound = true;
                            kingPosition = { row, col };
                        }
                    }
                }
                
                if (!kingFound) {
                    console.error(`King not found for ${color}`);
                }
                
                return kingPosition;
            }

            isSquareUnderAttack(row, col, byColor, excludeKing = false) {
                for (let startRow = 0; startRow < 8; startRow++) {
                    for (let startCol = 0; startCol < 8; startCol++) {
                        const piece = this.board[startRow][startCol];
                        if (piece && piece.color === byColor) {
                            // Skip king when checking for dangerous moves to avoid recursion
                            if (excludeKing && piece.type === 'KING') continue;
                            
                            const savedPlayer = this.currentPlayer;
                            this.currentPlayer = byColor;
                            const isValid = this.isValidMove(startRow, startCol, row, col);
                            this.currentPlayer = savedPlayer;
                            if (isValid) return true;
                        }
                    }
                }
                return false;
            }

            isInCheck(color) {
                const king = this.findKing(color);
                if (!king) {
                    console.error('King not found for', color, 'current board state:', this.board);
                    return false;
                }
                const oppositeColor = color === 'WHITE' ? 'BLACK' : 'WHITE';
                return this.isSquareUnderAttack(king.row, king.col, oppositeColor);
            }

            evaluateMove(startRow, startCol, endRow, endCol, color) {
                const piece = this.board[startRow][startCol];
                if (!piece || piece.color !== color) return false;

                // Prevent capturing kings during evaluation
                const targetPiece = this.board[endRow][endCol];
                if (targetPiece && targetPiece.type === 'KING') return false;

                // Try the move
                const savedTarget = this.board[endRow][endCol];
                const savedLastPawnMove = this.lastPawnDoubleMove;
                this.board[endRow][endCol] = { ...piece };
                this.board[startRow][startCol] = null;

                // Check if this move would leave or put king in check
                const movePutsInCheck = this.isInCheck(color);

                // Restore the board
                this.board[startRow][startCol] = piece;
                this.board[endRow][endCol] = savedTarget;
                this.lastPawnDoubleMove = savedLastPawnMove;

                return !movePutsInCheck;
            }

            hasLegalMoves(color) {
                if (color === this.currentPlayer) {
                    return this.validMovesCache.size > 0;
                }
                // Fall back to computation for non-current player
                return super.hasLegalMoves(color);
            }

            movePiece(startRow, startCol, endRow, endCol) {
                // Save state before making the move
                this.saveMoveState();

                const piece = this.board[startRow][startCol];
                
                if (!this.isValidMove(startRow, startCol, endRow, endCol)) {
                    this.log('Invalid move attempted');
                    return false;
                }

                const targetSquare = this.board[endRow][endCol];
                if (targetSquare && targetSquare.color === piece.color) return false;
                
                // Don't allow moving the last king
                if (piece.type === 'KING') {
                    const oppositeColor = piece.color === 'WHITE' ? 'BLACK' : 'WHITE';
                    if (!this.findKing(oppositeColor)) {
                        console.error('Cannot move last remaining king');
                        return false;
                    }
                }

                // Make temporary move to check for king safety
                const savedPiece = { ...piece };
                const savedTarget = this.board[endRow][endCol];
                const savedLastPawnMove = this.lastPawnDoubleMove;
                
                this.board[endRow][endCol] = savedPiece;
                this.board[startRow][startCol] = null;

                // Verify both kings are still on board and check for check
                const whiteKing = this.findKing('WHITE');
                const blackKing = this.findKing('BLACK');
                const movePutsOwnKingInCheck = this.isInCheck(piece.color);
                
                // Restore board state
                this.board[startRow][startCol] = piece;
                this.board[endRow][endCol] = savedTarget;
                this.lastPawnDoubleMove = savedLastPawnMove;

                if (!whiteKing || !blackKing) {
                    console.error('Invalid move - would remove king from board');
                    return false;
                }

                if (movePutsOwnKingInCheck) {
                    console.log('Move puts own king in check');
                    return false;
                }

                // Reset last pawn double move
                this.lastPawnDoubleMove = null;

                // Handle special moves
                if (piece.type === 'PAWN') {
                    // Handle pawn double move
                    if (Math.abs(startRow - endRow) === 2) {
                        this.lastPawnDoubleMove = { row: endRow, col: endCol };
                    }
                    // Handle en passant capture
                    else if (Math.abs(startCol - endCol) === 1 && !targetSquare) {
                        this.board[startRow][endCol] = null;
                    }
                    // Handle promotion
                    if (endRow === 0 || endRow === 7) {
                        this.board[endRow][endCol] = { type: 'QUEEN', color: piece.color, hasMoved: true };
                        this.board[startRow][startCol] = null;
                        // Skip the normal move as we've handled it
                        this.afterMove(piece);
                        return true;
                    }
                }
                // Handle castling
                else if (piece.type === 'KING' && Math.abs(startCol - endCol) === 2) {
                    const direction = endCol > startCol ? 1 : -1;
                    const rookCol = direction === 1 ? 7 : 0;
                    const newRookCol = direction === 1 ? endCol - 1 : endCol + 1;
                    
                    const rook = { ...this.board[startRow][rookCol] };
                    this.board[endRow][newRookCol] = { ...rook, hasMoved: true };
                    this.board[startRow][rookCol] = null;
                }

                const isCapture = this.board[endRow][endCol] !== null;
            
                // Generate notation before making the move
                const moveNotation = this.generateMoveNotation(startRow, startCol, endRow, endCol, isCapture);

                // Make the actual move
                this.board[endRow][endCol] = { ...piece, hasMoved: true };
                this.board[startRow][startCol] = null;

                // After successful move, before calling afterMove:
                const positionKey = this.generatePositionKey();
                this.positionHistory.set(positionKey, (this.positionHistory.get(positionKey) || 0) + 1);

                // After the move is made, check for check/checkmate
                const inCheck = this.isInCheck(this.currentPlayer);
                const hasLegalMoves = this.hasLegalMoves(this.currentPlayer);

                // Add check/checkmate symbols to notation
                let finalNotation = moveNotation;
                if (inCheck && !hasLegalMoves) {
                    finalNotation += '#';
                } else if (inCheck) {
                    finalNotation += '+';
                }

                // Log the move with notation
                this.log(null, finalNotation);

                this.afterMove(piece);
                return true;
            }

            afterMove(piece) {
                const previousPlayer = this.currentPlayer;
                this.currentPlayer = this.currentPlayer === 'WHITE' ? 'BLACK' : 'WHITE';
                this.computeAllValidMoves(); // Compute valid moves for next player
                
                // Update move counters
                this.halfMoveCounter++;
                if (this.currentPlayer === 'WHITE') {
                    this.moveCounter++;
                }

                // Update turn display
                const turnElement = document.getElementById('turn');
                turnElement.innerHTML = `
                    <div class="turn-info">
                        <span>${this.currentPlayer}'s turn</span>
                        <div id="ai-spinner" class="spinner"></div>
                    </div>
                    <span class="move-counter">Move: ${this.moveCounter} (${this.halfMoveCounter})</span>
                `;

                // Hide spinner immediately after creating it
                document.getElementById('ai-spinner').style.display = 'none';

                // Check game state
                const inCheck = this.isInCheck(this.currentPlayer);
                const hasLegalMoves = this.hasLegalMoves(this.currentPlayer);
                const insufficientMaterial = this.hasInsufficientMaterial();
                const repeatingPosition = this.hasRepeatingPosition();
                
                // Update game status
                const status = document.getElementById('status');
                
                if (repeatingPosition) {
                    status.textContent = 'Draw by threefold repetition!';
                    this.log('Game drawn due to threefold repetition');
                    this.gameOver = true;
                    
                    const modal = document.getElementById('checkmateModal');
                    const modalMessage = document.getElementById('modalMessage');
                    modalMessage.textContent = 'Game is a draw by threefold repetition!';
                    modal.classList.add('show');
                } else if (insufficientMaterial) {
                    status.textContent = 'Draw by insufficient material!';
                    this.log('Game drawn due to insufficient material');
                    this.gameOver = true;
                    
                    // Show insufficient material modal
                    const modal = document.getElementById('checkmateModal');
                    const modalMessage = document.getElementById('modalMessage');
                    modalMessage.textContent = 'Game is a draw by insufficient material!';
                    modal.classList.add('show');
                } else if (inCheck && !hasLegalMoves) {
                    // Checkmate
                    status.textContent = `Checkmate! ${piece.color} wins!`;
                    this.log(`Checkmate! ${piece.color} wins!`);
                    this.gameOver = true;
                    
                    // Show checkmate modal
                    const modal = document.getElementById('checkmateModal');
                    const modalMessage = document.getElementById('modalMessage');
                    modalMessage.textContent = `${piece.color} wins the game!`;
                    modal.classList.add('show');
                } else if (inCheck) {
                    // Check
                    status.textContent = `${this.currentPlayer} is in check!`;
                    this.log(`${this.currentPlayer} is in check!`);
                } else if (!hasLegalMoves) {
                    // Stalemate
                    status.textContent = 'Stalemate! Game is a draw.';
                    this.log('Stalemate! Game is a draw.');
                    this.gameOver = true;
                    
                    // Show stalemate modal
                    const modal = document.getElementById('checkmateModal');
                    const modalMessage = document.getElementById('modalMessage');
                    modalMessage.textContent = 'Game is a draw by stalemate!';
                    modal.classList.add('show');
                } else {
                    status.textContent = '';
                }

                // Render immediately after white's move
                this.renderBoard();
                
                if (this.currentPlayer === 'BLACK' && !this.gameOver) {
                    this.makeAIMove();
                }
            }

            computeAllValidMoves() {
                this.validMovesCache.clear();
                
                for (let startRow = 0; startRow < 8; startRow++) {
                    for (let startCol = 0; startCol < 8; startCol++) {
                        const piece = this.board[startRow][startCol];
                        if (!piece || piece.color !== this.currentPlayer) continue;

                        const key = `${startRow},${startCol}`;
                        const validMoves = [];

                        for (let endRow = 0; endRow < 8; endRow++) {
                            for (let endCol = 0; endCol < 8; endCol++) {
                                // Skip if destination has friendly piece
                                const targetPiece = this.board[endRow][endCol];
                                if (targetPiece && targetPiece.color === this.currentPlayer) {
                                    continue;
                                }

                                if (this.isValidMove(startRow, startCol, endRow, endCol) &&
                                    this.evaluateMove(startRow, startCol, endRow, endCol, this.currentPlayer)) {
                                    validMoves.push({ row: endRow, col: endCol });
                                }
                            }
                        }

                        if (validMoves.length > 0) {
                            this.validMovesCache.set(key, validMoves);
                        }
                    }
                }
            }

            getValidMovesForPiece(row, col) {
                const key = `${row},${col}`;
                return this.validMovesCache.get(key) || [];
            }

            renderBoard() {
                const boardElement = document.getElementById('board');
                boardElement.innerHTML = '';

                // Get valid moves if a piece is selected
                const validMoves = this.selectedPiece ? 
                    this.getValidMovesForPiece(this.selectedPiece.row, this.selectedPiece.col) : [];

                // Get opposing color for danger check
                const oppositeColor = this.currentPlayer === 'WHITE' ? 'BLACK' : 'WHITE';

                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 ? 'black' : 'white'}`;
                        
                        const piece = this.board[row][col];
                        
                        // Highlight valid moves
                        const isValidMove = validMoves.some(move => move.row === row && move.col === col);
                        if (isValidMove) {
                            square.classList.add('valid-move');
                            // Add special highlighting for captures
                            if (piece && piece.color !== this.currentPlayer) {
                                square.classList.add('valid-capture');
                            }

                            if (this.selectedPiece) {
                                // Check for checkmate moves
                                if (this.isCheckmateAfterMove(this.selectedPiece.row, this.selectedPiece.col, row, col)) {
                                    square.classList.add('checkmate');
                                }

                                // Check for dangerous moves (existing code)
                                const selectedPiece = this.board[this.selectedPiece.row][this.selectedPiece.col];
                                const savedTarget = this.board[row][col];
                                
                                this.board[row][col] = selectedPiece;
                                this.board[this.selectedPiece.row][this.selectedPiece.col] = null;
                                
                                const isDangerous = this.isSquareUnderAttack(row, col, oppositeColor, true);
                                
                                this.board[this.selectedPiece.row][this.selectedPiece.col] = selectedPiece;
                                this.board[row][col] = savedTarget;
                                
                                if (isDangerous) {
                                    square.classList.add('dangerous');
                                }
                            }
                        }

                        // Highlight selected piece
                        if (this.selectedPiece && 
                            row === this.selectedPiece.row && 
                            col === this.selectedPiece.col) {
                            square.classList.add('selected');
                        }

                        if (piece) {
                            const pieceSpan = document.createElement('span');
                            pieceSpan.className = `${piece.color.toLowerCase()}-piece`;
                            pieceSpan.textContent = PIECES[piece.color][piece.type];
                            square.appendChild(pieceSpan);
                        }

                        square.dataset.row = row;
                        square.dataset.col = col;
                        square.addEventListener('click', this.handleSquareClick.bind(this));
                        boardElement.appendChild(square);
                    }
                }
            }

            handleSquareClick(event) {
                if (this.gameOver) {
                    this.log('Game is already over');
                    return;
                }

                // Get row and col from clicked element or its parent
                let row, col;
                if (event.target.dataset.row) {
                    row = parseInt(event.target.dataset.row);
                    col = parseInt(event.target.dataset.col);
                } else if (event.target.parentElement.dataset.row) {
                    row = parseInt(event.target.parentElement.dataset.row);
                    col = parseInt(event.target.parentElement.dataset.col);
                } else {
                    return; // Invalid click target
                }

                // Validate position
                if (!this.isValidPosition(row, col)) {
                    return;
                }

                const piece = this.board[row][col];

                // Clicking on an already selected piece
                if (this.selectedPiece && 
                    this.selectedPiece.row === row && 
                    this.selectedPiece.col === col) {
                    this.selectedPiece = null;
                    this.renderBoard();
                    return;
                }

                // Clicking on a valid move for selected piece
                if (this.selectedPiece) {
                    const validMoves = this.getValidMovesForPiece(this.selectedPiece.row, this.selectedPiece.col);
                    const isValidMove = validMoves.some(move => move.row === row && move.col === col);

                    if (isValidMove) {
                        this.movePiece(this.selectedPiece.row, this.selectedPiece.col, row, col);
                        this.selectedPiece = null;
                        this.renderBoard();
                        return;
                    }
                }

                // Selecting a new piece
                if (piece && piece.color === this.currentPlayer) {
                    this.selectedPiece = { row, col };
                    this.renderBoard();
                }
            }

            evaluatePosition(color) {
                const pieceValues = {
                    'PAWN': 100,
                    'KNIGHT': 320,
                    'BISHOP': 330,
                    'ROOK': 500,
                    'QUEEN': 900,
                    'KING': 20000
                };

                // Positional bonuses for pieces
                const pawnPositionBonus = [
                    [0,  0,  0,  0,  0,  0,  0,  0],
                    [50, 50, 50, 50, 50, 50, 50, 50],
                    [10, 10, 20, 30, 30, 20, 10, 10],
                    [5,  5, 10, 25, 25, 10,  5,  5],
                    [0,  0,  0, 20, 20,  0,  0,  0],
                    [5, -5,-10,  0,  0,-10, -5,  5],
                    [5, 10, 10,-20,-20, 10, 10,  5],
                    [0,  0,  0,  0,  0,  0,  0,  0]
                ];

                let score = 0;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece) {
                            // Material value
                            let value = pieceValues[piece.type];
                            
                            // Position value
                            if (piece.type === 'PAWN') {
                                const positionRow = piece.color === 'WHITE' ? row : 7 - row;
                                value += pawnPositionBonus[positionRow][col];
                            }

                            // Center control bonus for minor pieces
                            if (['KNIGHT', 'BISHOP'].includes(piece.type)) {
                                if ((row === 3 || row === 4) && (col === 3 || col === 4)) {
                                    value += 10;
                                }
                            }

                            score += value * (piece.color === color ? 1 : -1);
                        }
                    }
                }
                return score;
            }

            minimax(depth, alpha, beta, maximizingPlayer) {
                // Check for leaf node
                if (depth === 0) {
                    return this.evaluatePosition('BLACK');
                }

                const currentColor = maximizingPlayer ? 'BLACK' : 'WHITE';
                const savedPlayer = this.currentPlayer;
                this.currentPlayer = currentColor;

                let bestScore = maximizingPlayer ? -Infinity : Infinity;
                
                for (let startRow = 0; startRow < 8; startRow++) {
                    for (let startCol = 0; startCol < 8; startCol++) {
                        const piece = this.board[startRow][startCol];
                        if (!piece || piece.color !== currentColor) continue;

                        for (let endRow = 0; endRow < 8; endRow++) {
                            for (let endCol = 0; endCol < 8; endCol++) {
                                if (this.isValidMove(startRow, startCol, endRow, endCol) &&
                                    this.evaluateMove(startRow, startCol, endRow, endCol, currentColor)) {
                                    
                                    // Make move
                                    const savedTarget = this.board[endRow][endCol];
                                    this.board[endRow][endCol] = piece;
                                    this.board[startRow][startCol] = null;

                                    const score = this.minimax(depth - 1, alpha, beta, !maximizingPlayer);

                                    // Undo move
                                    this.board[startRow][startCol] = piece;
                                    this.board[endRow][endCol] = savedTarget;

                                    if (maximizingPlayer) {
                                        bestScore = Math.max(bestScore, score);
                                        alpha = Math.max(alpha, score);
                                    } else {
                                        bestScore = Math.min(bestScore, score);
                                        beta = Math.min(beta, score);
                                    }

                                    if (beta <= alpha) {
                                        this.currentPlayer = savedPlayer;
                                        return bestScore;
                                    }
                                }
                            }
                        }
                    }
                }

                this.currentPlayer = savedPlayer;
                return bestScore;
            }

            findBestMove() {
                let bestScore = -Infinity;
                let bestMove = null;
                const depth = this.searchDepth; // Use configurable depth
                
                const savedPlayer = this.currentPlayer;
                this.currentPlayer = 'BLACK';

                for (let startRow = 0; startRow < 8; startRow++) {
                    for (let startCol = 0; startCol < 8; startCol++) {
                        const piece = this.board[startRow][startCol];
                        if (!piece || piece.color !== 'BLACK') continue;

                        for (let endRow = 0; endRow < 8; endRow++) {
                            for (let endCol = 0; endCol < 8; endCol++) {
                                if (this.isValidMove(startRow, startCol, endRow, endCol) &&
                                    this.evaluateMove(startRow, startCol, endRow, endCol, 'BLACK')) {
                                    
                                    const savedTarget = this.board[endRow][endCol];
                                    this.board[endRow][endCol] = piece;
                                    this.board[startRow][startCol] = null;

                                    const score = this.minimax(depth - 1, -Infinity, Infinity, false);

                                    this.board[startRow][startCol] = piece;
                                    this.board[endRow][endCol] = savedTarget;

                                    if (score > bestScore) {
                                        bestScore = score;
                                        bestMove = { startRow, startCol, endRow, endCol };
                                    }
                                }
                            }
                        }
                    }
                }

                this.currentPlayer = savedPlayer;
                return bestMove;
            }

            makeAIMove() {
                if (!this.isAIEnabled || this.currentPlayer !== 'BLACK' || this.gameOver) return;
                
                // Show spinner
                const spinner = document.getElementById('ai-spinner');
                spinner.style.display = 'inline-block';
                
                // Use setTimeout to ensure board renders before heavy calculation
                setTimeout(() => {
                    const move = this.findBestMove();
                    if (move) {
                        this.movePiece(move.startRow, move.startCol, move.endRow, move.endCol);
                        this.renderBoard();
                    }
                    spinner.style.display = 'none';
                }, 50); // Small delay to allow board to render
            }

            initializeControls() {
                const slider = document.getElementById('depth-slider');
                const depthValue = document.getElementById('depth-value');
                
                slider.addEventListener('input', (e) => {
                    this.searchDepth = parseInt(e.target.value);
                    depthValue.textContent = this.searchDepth;
                });

                // Add revert button listener
                document.getElementById('revertButton').addEventListener('click', () => {
                    if (this.revertMove() && this.currentPlayer === 'BLACK') {
                        // If we reverted to black's turn, revert one more time
                        this.revertMove();
                    }
                });
            }

            hasInsufficientMaterial() {
                // Count pieces for each player
                let whitePieces = new Map();
                let blackPieces = new Map();

                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (!piece) continue;

                        const piecesList = piece.color === 'WHITE' ? whitePieces : blackPieces;
                        piecesList.set(piece.type, (piecesList.get(piece.type) || 0) + 1);
                    }
                }

                // Helper function to check piece counts
                const hasPieces = (pieces) => {
                    const count = (type) => pieces.get(type) || 0;
                    
                    // If there are pawns, rooks, or queens, there's sufficient material
                    if (count('PAWN') > 0 || count('ROOK') > 0 || count('QUEEN') > 0) {
                        return false;
                    }

                    // King only
                    if (pieces.size === 1 && count('KING') === 1) {
                        return true;
                    }

                    // King and single knight/bishop
                    if (pieces.size === 2 && count('KING') === 1 && 
                        (count('KNIGHT') === 1 || count('BISHOP') === 1)) {
                        return true;
                    }

                    return false;
                };

                // Check if both players have insufficient material
                return hasPieces(whitePieces) && hasPieces(blackPieces);
            }

            // Add new method to generate position key
            generatePositionKey() {
                let key = '';
                // Add board position
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece) {
                            key += `${piece.type}${piece.color}${row}${col}`;
                        }
                    }
                }
                // Add current player
                key += this.currentPlayer;
                // Add castling rights
                for (let row of [0, 7]) {
                    for (let col of [0, 4, 7]) {
                        const piece = this.board[row][col];
                        if (piece && !piece.hasMoved) {
                            key += `${row}${col}`;
                        }
                    }
                }
                // Add en passant possibility
                if (this.lastPawnDoubleMove) {
                    key += `ep${this.lastPawnDoubleMove.row}${this.lastPawnDoubleMove.col}`;
                }
                return key;
            }

            // Add method to check for repetition
            hasRepeatingPosition() {
                const currentKey = this.generatePositionKey();
                const count = this.positionHistory.get(currentKey) || 0;
                return count >= 3; // Threefold repetition
            }

            getSquareNotation(row, col) {
                const files = 'abcdefgh';
                const ranks = '87654321';
                return files[col] + ranks[row];
            }

            getPieceNotation(piece) {
                const notation = {
                    'KING': 'K', 'QUEEN': 'Q', 'ROOK': 'R',
                    'BISHOP': 'B', 'KNIGHT': 'N'
                };
                return notation[piece.type] || '';
            }

            generateMoveNotation(startRow, startCol, endRow, endCol, capture = false) {
                const piece = this.board[startRow][startCol];
                let notation = '';

                // Handle castling
                if (piece.type === 'KING' && Math.abs(startCol - endCol) === 2) {
                    return endCol > startCol ? 'O-O' : 'O-O-O';
                }

                // Add piece letter (except for pawns)
                notation += this.getPieceNotation(piece);

                // Disambiguate moves if necessary
                const needsDisambiguation = this.needsDisambiguation(piece, startRow, startCol, endRow, endCol);
                if (needsDisambiguation.file) notation += this.getSquareNotation(startRow, startCol)[0];
                if (needsDisambiguation.rank) notation += this.getSquareNotation(startRow, startCol)[1];

                // Add capture symbol
                if (capture) {
                    if (piece.type === 'PAWN') notation += this.getSquareNotation(startRow, startCol)[0];
                    notation += 'x';
                }

                // Add destination square
                notation += this.getSquareNotation(endRow, endCol);

                // Handle pawn promotion
                if (piece.type === 'PAWN' && (endRow === 0 || endRow === 7)) {
                    notation += '=Q';
                }

                return notation;
            }

            needsDisambiguation(piece, startRow, startCol, endRow, endCol) {
                let needFile = false;
                let needRank = false;

                // Check other pieces of same type that could move to the same square
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (row === startRow && col === startCol) continue;

                        const otherPiece = this.board[row][col];
                        if (!otherPiece || otherPiece.type !== piece.type || otherPiece.color !== piece.color) continue;

                        if (this.isValidMove(row, col, endRow, endCol)) {
                            if (col !== startCol) needFile = true;
                            if (row !== startRow) needRank = true;
                        }
                    }
                }

                return { file: needFile, rank: needRank };
            }

            isCheckmateAfterMove(startRow, startCol, endRow, endCol) {
                // Save current state
                const piece = this.board[startRow][startCol];
                const targetPiece = this.board[endRow][endCol];
                const savedPlayer = this.currentPlayer;
                
                // Make temporary move
                this.board[endRow][endCol] = piece;
                this.board[startRow][startCol] = null;
                
                // Switch to opponent's perspective
                this.currentPlayer = this.currentPlayer === 'WHITE' ? 'BLACK' : 'WHITE';
                
                // Check if opponent is in check and has no legal moves
                const inCheck = this.isInCheck(this.currentPlayer);
                const hasLegalMoves = this.computeHasLegalMoves(this.currentPlayer);
                
                // Restore board state
                this.board[startRow][startCol] = piece;
                this.board[endRow][endCol] = targetPiece;
                this.currentPlayer = savedPlayer;
                
                return inCheck && !hasLegalMoves;
            }

            computeHasLegalMoves(color) {
                for (let startRow = 0; startRow < 8; startRow++) {
                    for (let startCol = 0; startCol < 8;startCol++) {
                        const piece = this.board[startRow][startCol];
                        if (!piece || piece.color !== color) continue;

                        for (let endRow = 0; endRow < 8; endRow++) {
                            for (let endCol = 0; endCol < 8; endCol++) {
                                if (this.isValidMove(startRow, startCol, endRow, endCol) &&
                                    this.evaluateMove(startRow, startCol, endRow, endCol, color)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }

            saveMoveState() {
                const state = {
                    board: this.board.map(row => row.map(piece => piece ? {...piece} : null)),
                    currentPlayer: this.currentPlayer,
                    lastPawnDoubleMove: this.lastPawnDoubleMove ? {...this.lastPawnDoubleMove} : null,
                    halfMoveCounter: this.halfMoveCounter,
                    moveCounter: this.moveCounter
                };
                this.moveStack.push(state);
                document.getElementById('revertButton').disabled = false;
            }

            revertMove() {
                if (this.moveStack.length === 0) return false;
                
                const prevState = this.moveStack.pop();
                this.board = prevState.board;
                this.currentPlayer = prevState.currentPlayer;
                this.lastPawnDoubleMove = prevState.lastPawnDoubleMove;
                this.halfMoveCounter = prevState.halfMoveCounter;
                this.moveCounter = prevState.moveCounter;
                
                // Update UI
                this.renderBoard();
                document.getElementById('revertButton').disabled = this.moveStack.length === 0;
                
                // Update turn display
                const turnElement = document.getElementById('turn');
                turnElement.innerHTML = `
                    <div class="turn-info">
                        <span>${this.currentPlayer}'s turn</span>
                        <div id="ai-spinner" class="spinner"></div>
                    </div>
                    <span class="move-counter">Move: ${this.moveCounter} (${this.halfMoveCounter})</span>
                `;

                // Remove last move from game log
                const gameLog = document.getElementById('game-log');
                if (gameLog.lastChild) {
                    gameLog.removeChild(gameLog.lastChild);
                }

                return true;
            }
        }

        const game = new Chess();
    </script>
</body>
</html>
