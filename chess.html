<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Client-side Chess Game</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #4f7480;
        }
        #chessboard {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 2px solid #333;
        }
        .tile {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 36px;
            position: relative;
        }
        .light {
            background-color: #eeeed2;
        }
        .dark {
            background-color: #769656;
        }
        .selected {
            background-color: rgb(235, 105, 105) !important;
        }
        .valid-move {
            background-color: lightgreen !important;
        }
        .castle-move {
            background-color: lightblue !important;
        }
        #status {
            margin-bottom: 20px;
            font-size: 24px;
        }
        .debug-label {
            position: absolute;
            font-size: 12px;
            color: red;
            pointer-events: none;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="status">Turn: White | Move Count: 0</div>
    <div id="chessboard"></div>
    <script>
        const boardElement = document.getElementById('chessboard');
        const statusElement = document.getElementById('status');
        const initialBoard = [
            ["♜", "♞", "♝", "♛", "♚", "♝", "♞", "♜"],
            ["♟", "♟", "♟", "♟", "♟", "♟", "♟", "♟"],
            ["", "", "", "", "", "", "", ""],
            ["", "", "", "", "", "", "", ""],
            ["", "", "", "", "", "", "", ""],
            ["", "", "", "", "", "", "", ""],
            ["♙", "♙", "♙", "♙", "♙", "♙", "♙", "♙"],
            ["♖", "♘", "♗", "♕", "♔", "♗", "♘", "♖"],
        ];

        const DEBUG_MODE = false;

        let currentTurn = "white";
        let moveCount = 0;
        let enPassantTarget = null;
        let kingInCheck = false;
        let whiteKingMoved = false;
        let blackKingMoved = false;
        let whiteRookMoved = { left: false, right: false };
        let blackRookMoved = { left: false, right: false };

        function createChessboard() {
            console.log('Function called: createChessboard');
            boardElement.innerHTML = '';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const tile = document.createElement('div');
                    tile.classList.add('tile');
                    tile.classList.add((row + col) % 2 === 0 ? 'light' : 'dark');
                    tile.dataset.row = row;
                    tile.dataset.col = col;
                    tile.textContent = initialBoard[row][col];
                    
                    if (DEBUG_MODE) {
                        const label = document.createElement('div');
                        label.classList.add('debug-label');
                        label.textContent = `${row},${col}`;
                        tile.appendChild(label);
                    }
                    
                    boardElement.appendChild(tile);
                }
            }
        }

        createChessboard();

        let selectedPiece = null;
        boardElement.addEventListener('click', (e) => {
            const target = e.target;
            if (!target.classList.contains('tile')) return;

            const row = parseInt(target.dataset.row);
            const col = parseInt(target.dataset.col);
            const piece = initialBoard[row][col];

            console.log(`Clicked tile at row ${row}, col ${col}, piece: "${piece}"`);

            if (selectedPiece) {
                // Validate the move based on the piece type
                if (isValidMove(selectedPiece, row, col)) {
                    console.log(`Moving ${selectedPiece.piece} from (${selectedPiece.row},${selectedPiece.col}) to (${row},${col})`);
                    movePiece(selectedPiece, row, col);
                    
                    // Handle en passant capture
                    if (enPassantTarget && row === enPassantTarget.row && col === enPassantTarget.col) {
                        console.log('En passant capture executed');
                        initialBoard[selectedPiece.row][col] = "";
                    }
                    // Move the selected piece
                    initialBoard[row][col] = selectedPiece.piece;
                    initialBoard[selectedPiece.row][selectedPiece.col] = "";
                    // Set enPassant target
                    if ((selectedPiece.piece === "♙" && selectedPiece.row === 6 && row === 4) ||
                        (selectedPiece.piece === "♟" && selectedPiece.row === 1 && row === 3)) {
                        enPassantTarget = { row: (selectedPiece.row + row) / 2, col };
                    } else {
                        enPassantTarget = null;
                    }
                    selectedPiece = null;
                    createChessboard();
                    clearHighlights();
                    // Switch turn
                    currentTurn = currentTurn === "white" ? "black" : "white";
                    moveCount++;
                    updateStatus();
                    console.log(`Turn changed to ${currentTurn}, move count: ${moveCount}`);

                    // Check for check
                    if (isKingInCheck(currentTurn)) {
                        console.log(`${currentTurn} king is in check!`);
                        statusElement.textContent = `${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)} is in check!`;
                        kingInCheck = true;
                    } else {
                        kingInCheck = false;
                    }

                    // Check for checkmate
                    if (isCheckmate(currentTurn)) {
                        console.log(`${currentTurn} king is in checkmate! Game Over! Move count: ${moveCount}`);
                        statusElement.textContent = `${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)} is in checkmate. Game over! Move count: ${moveCount}`;
                        checkMate = true;
                    }
                } else {
                    console.log(`Invalid move attempted from (${selectedPiece.row},${selectedPiece.col}) to (${row},${col})`);
                    // Allow selecting another piece if no valid moves are available
                    if (piece !== "" && isCorrectTurn(piece)) {
                        clearHighlights();
                        document.querySelector(`[data-row='${selectedPiece.row}'][data-col='${selectedPiece.col}']`).classList.remove('selected');
                        selectedPiece = { piece, row, col };
                        target.classList.add('selected');
                        highlightValidMoves(selectedPiece);
                    } else {
                        if (kingInCheck) {
                            statusElement.textContent = "Invalid move - king is in check! You must move to protect the king.";
                        } else {
                            statusElement.textContent = "Invalid move";
                        }
                        selectedPiece = null;
                        clearHighlights();
                    }
                }
            } else if (piece !== "" && isCorrectTurn(piece)) {
                console.log(`Selected piece ${piece} at (${row},${col})`);
                // Select a piece if it is the correct turn
                if (selectedPiece) {
                    document.querySelector(`[data-row='${selectedPiece.row}'][data-col='${selectedPiece.col}']`).classList.remove('selected');
                }
                selectedPiece = { piece, row, col };
                target.classList.add('selected');
                highlightValidMoves(selectedPiece);
            }
        });

        function isValidMove(selectedPiece, targetRow, targetCol) {
            console.log(`Function called: isValidMove - Piece: ${selectedPiece.piece} from (${selectedPiece.row},${selectedPiece.col}) to (${targetRow},${targetCol})`);
            console.log(`Validating move for ${selectedPiece.piece} to (${targetRow},${targetCol})`);
            const { piece, row, col } = selectedPiece;

            // If king is in check, verify if this move will get king out of check
            if (kingInCheck) {
                // Temporarily make the move
                const originalPiece = initialBoard[targetRow][targetCol];
                initialBoard[targetRow][targetCol] = piece;
                initialBoard[row][col] = "";

                // Check if the king is still in check after this move
                const stillInCheck = isKingInCheck(currentTurn);

                // Undo the move
                initialBoard[row][col] = piece;
                initialBoard[targetRow][targetCol] = originalPiece;

                // If king is still in check, this is not a valid move
                if (stillInCheck) {
                    console.log('Move rejected - king would still be in check');
                    return false;
                }
            }

            const deltaRow = targetRow - row;
            const deltaCol = targetCol - col;

            // Prevent moving to a square occupied by a piece of the same color
            if (isSameColor(piece, initialBoard[targetRow][targetCol])) {
                return false;
            }

            switch (piece) {
                case "♙": // White Pawn
                    if (deltaRow === -1 && deltaCol === 0 && initialBoard[targetRow][targetCol] === "") {
                        return true;
                    }
                    if (row === 6 && deltaRow === -2 && deltaCol === 0 && initialBoard[targetRow][targetCol] === "" && initialBoard[row - 1][col] === "") {
                        return true;
                    }
                    if (deltaRow === -1 && Math.abs(deltaCol) === 1 && (isOpponentPiece(piece, initialBoard[targetRow][targetCol]) || (enPassantTarget && targetRow === enPassantTarget.row && targetCol === enPassantTarget.col))) {
                        return true;
                    }
                    return false;
                case "♟": // Black Pawn
                    if (deltaRow === 1 && deltaCol === 0 && initialBoard[targetRow][targetCol] === "") {
                        return true;
                    }
                    if (row === 1 && deltaRow === 2 && deltaCol === 0 && initialBoard[targetRow][targetCol] === "" && initialBoard[row + 1][col] === "") {
                        return true;
                    }
                    if (deltaRow === 1 && Math.abs(deltaCol) === 1 && (isOpponentPiece(piece, initialBoard[targetRow][targetCol]) || (enPassantTarget && targetRow === enPassantTarget.row && targetCol === enPassantTarget.col))) {
                        return true;
                    }
                    return false;
                case "♖": // White Rook
                case "♜": // Black Rook
                    return (deltaRow === 0 || deltaCol === 0) && isPathClear(row, col, targetRow, targetCol);
                case "♘": // White Knight
                case "♞": // Black Knight
                    return (Math.abs(deltaRow) === 2 && Math.abs(deltaCol) === 1) || (Math.abs(deltaRow) === 1 && Math.abs(deltaCol) === 2);
                case "♗": // White Bishop
                case "♝": // Black Bishop
                    return Math.abs(deltaRow) === Math.abs(deltaCol) && isPathClear(row, col, targetRow, targetCol);
                case "♕": // White Queen
                case "♛": // Black Queen
                    return (deltaRow === 0 || deltaCol === 0 || Math.abs(deltaRow) === Math.abs(deltaCol)) && isPathClear(row, col, targetRow, targetCol);
                case "♔": // White King
                    if (Math.abs(deltaRow) <= 1 && Math.abs(deltaCol) <= 1) {
                        whiteKingMoved = true;
                        return true;
                    }
                    // Castling
                    if (!whiteKingMoved && deltaRow === 0 && Math.abs(deltaCol) === 2) {
                        if (deltaCol === 2 && !whiteRookMoved.right && isPathClear(row, col, row, col + 3)) {
                            return true;
                        }
                        if (deltaCol === -2 && !whiteRookMoved.left && isPathClear(row, col, row, col - 4)) {
                            return true;
                        }
                    }
                    return false;
                case "♚": // Black King
                    if (Math.abs(deltaRow) <= 1 && Math.abs(deltaCol) <= 1) {
                        blackKingMoved = true;
                        return true;
                    }
                    // Castling
                    if (!blackKingMoved && deltaRow === 0 && Math.abs(deltaCol) === 2) {
                        if (deltaCol === 2 && !blackRookMoved.right && isPathClear(row, col, row, col + 3)) {
                            return true;
                        }
                        if (deltaCol === -2 && !blackRookMoved.left && isPathClear(row, col, row, col - 4)) {
                            return true;
                        }
                    }
                    return false;
                default:
                    return false;
            }
        }

        function movePiece(selectedPiece, targetRow, targetCol) {
            const { piece, row, col } = selectedPiece;
            initialBoard[targetRow][targetCol] = piece;
            initialBoard[row][col] = "";

            // Handle castling
            if (piece === "♔" && Math.abs(targetCol - col) === 2) {
                if (targetCol === 6) { // King-side castling
                    initialBoard[row][5] = "♖";
                    initialBoard[row][7] = "";
                } else if (targetCol === 2) { // Queen-side castling
                    initialBoard[row][3] = "♖";
                    initialBoard[row][0] = "";
                }
            } else if (piece === "♚" && Math.abs(targetCol - col) === 2) {
                if (targetCol === 6) { // King-side castling
                    initialBoard[row][5] = "♜";
                    initialBoard[row][7] = "";
                } else if (targetCol === 2) { // Queen-side castling
                    initialBoard[row][3] = "♜";
                    initialBoard[row][0] = "";
                }
            }
        }

        function isPathClear(startRow, startCol, endRow, endCol) {
            console.log(`Function called: isPathClear - From (${startRow},${startCol}) to (${endRow},${endCol})`);
            const stepRow = startRow < endRow ? 1 : startRow > endRow ? -1 : 0;
            const stepCol = startCol < endCol ? 1 : startCol > endCol ? -1 : 0;
            let currentRow = startRow + stepRow;
            let currentCol = startCol + stepCol;

            while (currentRow !== endRow || currentCol !== endCol) {
                if (initialBoard[currentRow][currentCol] !== "") {
                    return false;
                }
                currentRow += stepRow;
                currentCol += stepCol;
            }

            return true;
        }

        function isSameColor(piece1, piece2) {
            console.log(`Function called: isSameColor - Comparing pieces: "${piece1}" and "${piece2}"`);
            if (piece1 === "" || piece2 === "") return false;
            const whitePieces = "♔♕♖♗♘♙";
            const blackPieces = "♚♛♜♝♞♟";
            return (whitePieces.includes(piece1) && whitePieces.includes(piece2)) || (blackPieces.includes(piece1) && blackPieces.includes(piece2));
        }

        function isOpponentPiece(piece, targetPiece) {
            console.log(`Function called: isOpponentPiece - Piece: "${piece}", Target: "${targetPiece}"`);
            if (targetPiece === "") return false;
            return !isSameColor(piece, targetPiece);
        }

        function isCorrectTurn(piece) {
            console.log(`Function called: isCorrectTurn - Piece: "${piece}", Current turn: ${currentTurn}`);
            const whitePieces = "♔♕♖♗♘♙";
            const blackPieces = "♚♛♜♝♞♟";
            return (currentTurn === "white" && whitePieces.includes(piece)) || (currentTurn === "black" && blackPieces.includes(piece));
        }

        function highlightValidMoves(selectedPiece) {
            console.log(`Function called: highlightValidMoves - Piece: ${selectedPiece.piece} at (${selectedPiece.row},${selectedPiece.col})`);
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (isValidMove(selectedPiece, row, col)) {
                        const tile = document.querySelector(`[data-row='${row}'][data-col='${col}']`);
                        tile.classList.add('valid-move');
                    }
                }
            }

            // Highlight castling moves
            if (selectedPiece.piece === "♔" && !whiteKingMoved) {
                if (!whiteRookMoved.right && isPathClear(selectedPiece.row, selectedPiece.col, selectedPiece.row, selectedPiece.col + 3)) {
                    document.querySelector(`[data-row='${selectedPiece.row}'][data-col='${selectedPiece.col + 2}']`).classList.add('castle-move');
                }
                if (!whiteRookMoved.left && isPathClear(selectedPiece.row, selectedPiece.col, selectedPiece.row, selectedPiece.col - 4)) {
                    document.querySelector(`[data-row='${selectedPiece.row}'][data-col='${selectedPiece.col - 2}']`).classList.add('castle-move');
                }
            } else if (selectedPiece.piece === "♚" && !blackKingMoved) {
                if (!blackRookMoved.right && isPathClear(selectedPiece.row, selectedPiece.col, selectedPiece.row, selectedPiece.col + 3)) {
                    document.querySelector(`[data-row='${selectedPiece.row}'][data-col='${selectedPiece.col + 2}']`).classList.add('castle-move');
                }
                if (!blackRookMoved.left && isPathClear(selectedPiece.row, selectedPiece.col, selectedPiece.row, selectedPiece.col - 4)) {
                    document.querySelector(`[data-row='${selectedPiece.row}'][data-col='${selectedPiece.col - 2}']`).classList.add('castle-move');
                }
            }
        }

        function clearHighlights() {
            console.log('Function called: clearHighlights');
            document.querySelectorAll('.valid-move, .castle-move').forEach(tile => {
                tile.classList.remove('valid-move', 'castle-move');
            });
        }

        function updateStatus() {
            console.log(`Function called: updateStatus - Turn: ${currentTurn}, Move count: ${moveCount}`);
            statusElement.textContent = `Turn: ${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)} | Move Count: ${moveCount}`;
        }

        function isCheckmate(turn) {
            console.log(`Function called: isCheckmate - Checking ${turn}'s position`);
            console.log(`Checking if ${turn} king is in checkmate`);
            const kingPiece = turn === "white" ? "♔" : "♚";
            let kingPosition = null;

            // Find the king's position
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (initialBoard[row][col] === kingPiece) {
                        kingPosition = { row, col };
                        break;
                    }
                }
                if (kingPosition) break;
            }

            if (!kingPosition) return false;

            // Check if any move can prevent checkmate
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = initialBoard[row][col];
                    if (piece !== "" && isCorrectTurn(piece)) {
                        selectedPiece = { piece, row, col };
                        for (let targetRow = 0; targetRow < 8; targetRow++) {
                            for (let targetCol = 0; targetCol < 8; targetCol++) {
                                if (isValidMove(selectedPiece, targetRow, targetCol)) {
                                    // Temporarily make the move
                                    const originalPiece = initialBoard[targetRow][targetCol];
                                    initialBoard[targetRow][targetCol] = piece;
                                    initialBoard[row][col] = "";

                                    // Check if the king is still in check
                                    const inCheck = isKingInCheck(turn);

                                    // Undo the move
                                    initialBoard[row][col] = piece;
                                    initialBoard[targetRow][targetCol] = originalPiece;

                                    if (!inCheck) {
                                        selectedPiece = null;
                                        return false;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            selectedPiece = null;
            return true;
        }

        function isKingInCheck(turn) {
            console.log(`Function called: isKingInCheck - Checking ${turn}'s king`);
            const kingPiece = turn === "white" ? "♔" : "♚";
            let kingPosition = null;

            // Find the king's position
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (initialBoard[row][col] === kingPiece) {
                        kingPosition = { row, col };
                        break;
                    }
                }
                if (kingPosition) break;
            }

            if (!kingPosition) return false;

            // Check if any opponent piece can attack the king
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = initialBoard[row][col];
                    if (piece !== "" && isOpponentPiece(piece, kingPiece)) {
                        if (isValidMove({ piece, row, col }, kingPosition.row, kingPosition.col)) {
                            return true;
                        }
                    }
                }
            }

            return false;
        }
    </script>
</body>
</html>
